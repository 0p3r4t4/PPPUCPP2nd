# 10.exercise.06.md

## Statement

Define a __Roman\_int__ class for holding Roman numerals (as __int__s) with a
__<<__ and __>>__. Provide __Roman\_int__ with an __as\_int()__ member that
returns the __int__ value, so that if __r__ is a __Roman\_int__, we can write
__cout << "Roman " << r << " equals " << r.as\_int() << '\n';__.

## Analysis

### Roman numerals

We were told that Roman numerals are expressed by a set of letter with
different values: M, D, C, L, X, V, and I, respectilvely equivalents to 1000,
500, 100, 50, 10, 5 and 1. The awkwardness comes when we were told that, to
express 900, we must write CM, kind of 100 substracted to 1000.

For this exercise I prefer to take a different point of view where the letters
aren't the core but "particles". I call particles to the letters or
combinations of them that have a defined value. The particles are (read below
for explanation about particles properties):

  Particle | Value | Repetition | Conflicts | Inhibits
  ----------------------------------------------------
     M     | 1000  |    4       |           |
     CM    | 900   |    1       | D, CD     |   C
     D     | 500   |    1       | CM, CD    |
     CD    | 400   |    1       | CM, D     |   C
     C     | 100   |    4       |           |
     XC    | 90    |    1       | L, XL     |   X
     L     | 50    |    1       | XC, XL    |
     XL    | 40    |    1       | XC, L     |   X
     X     | 10    |    4       |           |
     IX    | 9     |    1       | V, IV     |   I
     V     | 5     |    1       | IX, IV    |
     IV    | 4     |    1       | IX, V     |   I
     I     | 1     |    4       |           |

These particles could appear or not, and some of them could be consecutively
repeated. There is some discussion about if these particles could be repeated 3
or 4 times, so both IV and IIII means 4. Since it barely affects my analysis I
will take the 4-repetition option.

With those particles and the 4-repetition option, the numbers we can represent
range from 1 to 49999 (remember that Roman numerals have no concept of zero).

The advantage of particles is that they appear in order of decreasing
magnitude, so we could parse a Roman numeral simply traversing the particles
from the greatest one to the lowest.

There are some particles that conflict with others. In sets {CM, D, CD}, {XC,
L, XL} and {IX, V, IV}, only one particle from the set could appear in the
Roman numeral. Explanation: once CM (900) appears, there is zero interest in
adding D (500) or CD (400).

There are some particles that inhibit others; if CM (900) or CD (400) appear,
there is no chance for C (100) to appear after since 900+100 is 1000 and
expressed with M, and 400+100 is 500 and expressed with D.

Taking account of this all, I plan to implement a lookup table that condenses
all the information contained in the former table.

### Input behavior

I want __>>__ operator to work on __Roman\_int__ as similar as I could do. I
mean, if we have an input as _3e10-0.2_ and we read two __double__s, we obtain
_3e10_ and _-0.2_.

So, if we have an input as _MMXCCV_, that at first seems wrong, and the program
read two __Roman\_int__s, I want to obtain _MMX_ and _CCV_ and not an error.
This forces me to work on the __char__ level instead of working with strings
and also bind me to return to the input stream those characters that,
previously read, don't belong to the __Roman\_int__ currently read.

As the book already brings up, this behavior can be difficult to obtain.

## Design

### The Look Up Table (LUT)

We could express the exposed knowledge about Roman numerals with code or data.
The use of a LUT (a pretty simple one, in this case) seems like a good idea to
me. You can argue that it is some kind of cheating, but the truth is that a
tiny amount of data tremendously simplifies the parsing and composing of Roman
numerals, so, why not?

Help with parsing
Help with particle testing
Help with composing

### Parsing a Roman numeral

### Composing a Roman numeral

### The cheat

I want to have a __Roman\_int__ constructor that receives a Roman numeral
string as argument and parses it to get the __int__. As we already have a
parsing function we can take advantage of it. The problem? The parsing function
works over an __istream__.

And here is where I cheat by introducing something not mentioned on the book;
the __stringstream__. As excuse I can say that its use is not different from
what we do with regular __iostream__s.

One point to take care of is that, in the case of the constructor, the string
parameter must be a well formed and unique Roman numeral, so we must assure
that __parse\_roman()__ consumes the string completely and nothing else remains
on the __stringstream__. I've done that by reading a __string__ from the
__stringstream__ and test if its size equals 0.
