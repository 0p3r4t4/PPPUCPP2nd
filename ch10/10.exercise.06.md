# 10.exercise.06.md

## Statement

Define a __Roman\_int__ class for holding Roman numerals (as __int__s) with a
__<<__ and __>>__. Provide __Roman\_int__ with an __as\_int()__ member that
returns the __int__ value, so that if __r__ is a __Roman\_int__, we can write
__cout << "Roman " << r << " equals " << r.as\_int() << '\n';__.

## Analysis

### Roman numerals

We were told that Roman numerals are expressed by a set of letters with
different values: M, D, C, L, X, V, and I, respectilvely equivalents to 1000,
500, 100, 50, 10, 5 and 1. The awkwardness comes when we were told that, to
express 900, we must write CM, kind of 100 substracted to 1000.

For this exercise I prefer to take a different approach where the letters
aren't the core concept but _particles_. I call _particles_ to the letters or
combinations of them that have a defined value. The particles are (read below
for explanation about particles properties):

| Particle | Value | Repetition | Conflicts with | Inhibits |
| -------- |:-----:|:----------:|:--------------:|:--------:|
|    M     | 1000  |    4       | -              |   -      |
|    CM    | 900   |    1       | D, CD          |   C      |
|    D     | 500   |    1       | CM, CD         |   -      |
|    CD    | 400   |    1       | CM, D          |   C      |
|    C     | 100   |    4       | -              |   -      |
|    XC    | 90    |    1       | L, XL          |   X      |
|    L     | 50    |    1       | XC, XL         |   -      |
|    XL    | 40    |    1       | XC, L          |   X      |
|    X     | 10    |    4       | -              |   -      |
|    IX    | 9     |    1       | V, IV          |   I      |
|    V     | 5     |    1       | IX, IV         |   -      |
|    IV    | 4     |    1       | IX, V          |   I      |
|    I     | 1     |    4       | -              |   -      |

These particles could appear or not, and some of them could be consecutively
repeated. There is some discussion about if these particles could be repeated 3
or 4 times, so both IV and IIII means 4. Since it barely affects my analysis I
will take the _4-repetition_ option. With this decision the numbers we can
represent range from 1 to 49999 (remember that Roman numerals have no concept
of zero).

The advantage of _particles_ is that they appear in order of decreasing
magnitude, so we could parse a Roman numeral by simply traversing the
_particles_ from the greatest to the lowest.

There are some particles that conflict with others. In sets ___{CM, D, CD}___,
___{XC, L, XL}___ and ___{IX, V, IV}___, only one _particle_ from the set could
appear in the Roman numeral. Explanation: once CM (900) appears, there is no
interest in adding D (500) or CD (400).

There are some _particles_ that inhibit others; if CM (900) or CD (400) appear,
there is no chance for C (100) to appear after since 900+100 is 1000 and
expressed with M, and 400+100 is 500 and expressed with D.

Taking account of all this, I plan to implement a lookup table that condenses
all the information contained in the former table.

### Input behavior

I want __>>__ operator to work on __Roman\_int__ as similar as it does on
fundamental types. I mean, if we have an input as _3e10-0.2_ and we read two
__double__s, we obtain _3e10_ and _-0.2_.

So, if we have an input as _MMXCCV_, that at first sight seems wrong, and the
program reads two __Roman\_int__s, I want to obtain _MMX_ and _CCV_ and not an
error.  This forces me to work on the __char__ level instead of working with
strings and also bind me to return to the input stream those characters that,
previously read, don't belong to the __Roman\_int__ currently read.

As the book already brings up, this behavior can be difficult to obtain.

## Design

### The Lookup Table (LUT)

We could express the table about Roman numerals in analysis with code or data.
The use of a LUT (a pretty simple one, in this case) seems like a good idea to
me. You can argue that it is some kind of cheat, but the truth is that a tiny
amount of data tremendously simplifies the parse and composition of Roman
numerals, so, why not?

The LUT is composed by a series of rows, modeled with a struct:

    struct lut_row {
        string particle;
        int value;
        size_t next;
    };

With the __next__ member, an index to the LUT, we express, on one step, the
_conflict with_ and _inhibition_ concepts, just by saying which particle could
appear after the current one.  If we found a __CM__, neither __D__ or __CD__
(by conflict) or __C__ (by inhibition) could appear after, so __next__ points
to the __XC__ particle as candidate.

For repetition, we could add a member to __lut\_row__ or hardcode it on the
LUT. With a member we must track repetition, while parsing or composing, with a
counter. So let's be verbose. The final LUT looks like this:

| Index | Particle | Value | Next |
|:-----:|:--------:|:-----:|:----:|
|   0   |    M     |  1000 |   1  |
|   1   |    M     |  1000 |   2  |
|   2   |    M     |  1000 |   3  |
|   3   |    M     |  1000 |   4  |
|   4   |    CM    |   900 |  11  |
|   5   |    D     |   500 |   7  |
|   6   |    CD    |   400 |  11  |
|   7   |    C     |   100 |   8  |
|   8   |    C     |   100 |   9  |
|   9   |    C     |   100 |  10  |
|  10   |    C     |   100 |  11  |
|  11   |    XC    |    90 |  18  |
|  12   |    L     |    50 |  14  |
|  13   |    XL    |    40 |  18  |
|  14   |    X     |    10 |  15  |
|  15   |    X     |    10 |  16  |
|  16   |    X     |    10 |  17  |
|  17   |    X     |    10 |  18  |
|  18   |    IX    |     9 | END  |
|  19   |    V     |     5 |  21  |
|  20   |    IV    |     4 | END  |
|  21   |    I     |     1 |  22  |
|  22   |    I     |     1 |  23  |
|  23   |    I     |     1 |  24  |
|  24   |    I     |     1 | END  |

This LUT serves us for three kinds of work:

  - parsing
  - particle testing
  - composing

### Parsing a Roman numeral

Given an __istream__, parsing is done by obtaining a valid __particle__ from it
and search it on the LUT, adding its __value__ to a accumulator and _jumping_
to the __next__ index to begin the search for the next particle obtained.
We could express this idea in pseudo code:

    accumulator = 0
    index = 0
    while index != END
        obtain particle
        index = search particle position in LUT begining at index
        add LUT[index].value to accumulator
        index = LUT[index].next
    return accumulator

that translates almost directly to C++ (see __parse_roman()__ in
_10.exercise.06.roman.cpp_)

### Composing a Roman numeral

### The cheat

I want to have a __Roman\_int__ constructor that receives a Roman numeral
string as argument and parses it to obtain the equivalent __int__. As we already have a
parsing function we can take advantage of it. The problem? The parsing function
works over an __istream__.

And here is where I cheat by introducing something not mentioned on the book;
the __stringstream__. As excuse I can say that its use is not different at all
from what we have done with regular __istream__s.

One point to take care of is that, in the case of the constructor, the string
parameter must be a well formed and unique Roman numeral, so we must assure
that __parse\_roman()__ consumes the string completely and nothing else remains
on the __stringstream__. I've done that by reading a __string__ from the
__stringstream__ and test if its size equals 0.
